# 考前參考資料 (4/10): 現代前端開發 - 工具鏈與渲染策略

本文檔專注於您在前端優化術語（如 Tree Shaking）和渲染策略上的常見誤區，提供從原理到權衡的深度解析。

## 一、前端優化術語精準辨析

**誤區回顧：** 將所有減小檔案體積的技術都歸為一類。
**核心觀念：** 現代前端打包工具（如 Webpack, Vite）像一個多功能的工廠，`Tree Shaking`, `Minification`, `Code Splitting`, `Bundling` 是工廠裡不同的生產線，各有其職。

### Mermaid 圖解：前端打包流程

```mermaid
graph TD
    A[原始碼 (ES6 Modules)] --> B[Tree Shaking (移除死碼)]
    B --> C[Bundling (合併檔案)]
    C --> D[Minification (壓縮程式碼)]
    D --> E[Code Splitting (按需分割)]
    E --> F[最終打包檔案 (Bundles)]

    subgraph 打包優化流程
        B
        D
        E
    end
```

### Tree Shaking (搖樹)

- **做什麼？** 移除未被使用的程式碼。它依賴 import 和 export 靜態分析，如果你從函式庫引入了 10 個函式但只用了 2 個，它會把那 8 個沒用到的從最終產物中刪除。
- **比喻：** 外科手術，精準切除無用組織。

### Minification (壓縮/醜化)

- **做什麼？** 減小已使用的程式碼的字元數。它通過縮短變數名、移除空白和註解等方式來實現。
- **比喻：** 物理壓縮，把棉花壓成棉花糖。

### Code Splitting (程式碼分割)

- **做什麼？** 將一個巨大的 JS 檔案，根據規則（如路由）分割成多個小塊 (chunks)。
- **解決什麼問題？** 解決首屏載入過慢的問題。使用者訪問首頁時，只需要下載首頁的 chunk，而不是整個應用的程式碼。
- **比喻：** 百科全書按章節分冊，讀哪章拿哪冊。

### Bundling (打包)

- **做什麼？** 將多個 JS 檔案和依賴合併成一個或幾個檔案。
- **解決什麼問題？** 解決瀏覽器早期對模組化支援不佳和過多 HTTP 請求導致的效能問題。
- **比喻：** 把零散的零件組裝成一台完整的機器。

## 二、前端渲染策略的權衡藝術

**誤區回顧：** 認為只要能動態產生頁面，SSR 就是最佳解。
**核心觀念：** 沒有最好的渲染策略，只有最適合特定場景的策略。這是一個在伺服器成本、資料新鮮度和使用者體驗之間的權衡。

### 策略比較表

| 策略           | CSR (客戶端渲染)      | SSR (伺服器端渲染)    | SSG (靜態網站生成)   | ISR (增量靜態再生)         |
| -------------- | --------------------- | --------------------- | -------------------- | -------------------------- |
| HTML 生成時機  | 瀏覽器中 (執行 JS 後) | 伺服器上 (每次請求時) | 伺服器上 (建構時)    | 伺服器上 (建構時 + 過期後) |
| 首屏速度 (FCP) | 慢                    | 快                    | 極快                 | 極快                       |
| SEO 友好度     | 差                    | 佳                    | 極佳                 | 極佳                       |
| 資料新鮮度     | 即時                  | 即時                  | 舊的 (需重新建構)    | 接近即時                   |
| 伺服器負載     | 極低                  | 高                    | 無 (CDN)             | 低                         |
| 適用場景       | 後台管理系統、Web App | 高度個人化的頁面      | 部落格、文件、行銷頁 | 新聞網站、電商商品頁       |

### 深度解析：為什麼 ISR 更適合新聞網站？

一個新聞頁面有兩個特點：

1. 內容會更新，但不是每秒都在變。
2. 對絕大多數使用者來說，在同一時間看到的內容是相同的。

**如果用 SSR：** 每來一個使用者，伺服器都要重新從資料庫讀取新聞內容、重新產生一次 HTML。如果一秒鐘有一萬個請求，伺服器和資料庫就會被重複查詢一萬次，這是巨大的浪費。

**如果用 ISR (設定過期時間為 60 秒)：**

1. 第一個使用者來訪，伺服器產生 HTML 並將其快取起來。
2. 接下來 60 秒內的所有使用者，都直接從快取中獲取這個靜態 HTML，速度飛快，伺服器幾乎沒有負擔。
3. 60 秒後，下一個使用者來訪，他會立即收到舊的快取頁面（保證體驗），同時後台會非同步地觸發一次頁面重新生成。
4. 生成完畢後，快取被更新，等待下一個 60 秒的週期。

**結論：** ISR 用「可接受的資料延遲」（60 秒）換取了「極高的效能和極低的伺服器成本」，完美契合了新聞網站的需求。
