# 考前參考資料 (6/10): 分散式系統理論 - CAP 與架構模式

本文檔專注於您在 CAP 定理、CQRS 等高階架構模式上的常見誤區，提供從理論到權衡的深度解析。

## 一、CAP 定理：分散式系統的「不可能三角」

**誤區回顧：** 認為系統總要盡力處理寫入，之後再想辦法解決衝突。
**核心觀念：** CAP 理論由 Eric Brewer 提出，指出在一個分散式系統中，**一致性 (Consistency)**、**可用性 (Availability)** 和**分區容錯性 (Partition Tolerance)** 這三者，你**最多只能同時滿足其中兩項**。

- **術語深度解析：**
  - **C - 一致性 (Consistency)：** 指**強一致性**或**線性一致性**。任何讀取操作都應該能讀取到**最新**的寫入資料。所有節點在同一時間看到的資料是完全一致的。
  - **A - 可用性 (Availability)：** 任何（非故障）節點接收到的請求，都必須能在有限時間內給出回應（不能是錯誤或超時）。系統必須**一直在线**。
  - **P - 分區容錯性 (Partition Tolerance)：** 當系統節點之間出現網路故障，導致訊息丟失或延遲（即產生「網路分區」）時，系統**仍然能夠繼續運行**。

**核心權衡：** 在現代網路環境下，網路故障是常態，所以 **P (分區容錯性) 是一個必須滿足的前提**。因此，架構師的真正選擇是在 C 和 A 之間進行取捨。

### Mermaid 圖解：CAP 的選擇

```mermaid
graph TD
    subgraph "當 P (網路分區) 發生時"
        A[選擇 CP] --> B(犧牲 A: 可用性)
        B --> C[為了保證 C (強一致性), 系統拒絕部分請求, 直到分區恢復]

        D[選擇 AP] --> E(犧牲 C: 強一致性)
        E --> F[為了保證 A (可用性), 系統允許分區兩邊獨立寫入, 接受資料可能不一致]
    end

    style C fill:#f99,stroke:#333,stroke-width:2px
    style F fill:#9f9,stroke:#333,stroke-width:2px
```

### 選擇 CP (Consistency + Partition Tolerance)

**比喻：** 銀行轉帳系統。當網路分區導致無法確認對方帳戶狀態時，系統會直接拒絕你的轉帳請求，顯示「交易失敗，請稍後再試」。它寧可讓你用不了，也絕不允許出現帳目錯誤。

**代表系統：** 傳統的關聯式資料庫叢集、HBase、MongoDB (在特定設定下)。

### 選擇 AP (Availability + Partition Tolerance)

**比喻：** 社交媒體發文。你在網路不好的情況下發了一篇貼文，系統顯示發送成功。你的朋友可能暫時看不到，但過一會兒網路恢復後，資料最終會同步過去。系統優先保證你能「用」，資料的短暫不一致是可以接受的。

**代表系統：** Cassandra、DynamoDB、大多數 NoSQL 資料庫。

## 二、CQRS 架構模式：讀寫的權責分離

**誤區回顧：** 認為 CQRS 會減少硬體需求或簡化邏輯。
**核心觀念：** CQRS (Command Query Responsibility Segregation) 的核心思想是將應用程式的寫入 (Command) 操作和讀取 (Query) 操作分離到不同的模型中。

### Mermaid 圖解：傳統架構 vs. CQRS 架構

```mermaid
graph TD
    subgraph 傳統架構
        User1[User] --> App1[Application]
        App1 --> Model1[單一模型 (讀寫共用)]
        Model1 <--> DB1[單一資料庫]
    end

    subgraph CQRS 架構
        User2[User] --> App2[Application]
        App2 -- 寫入 --> CommandModel[命令模型]
        CommandModel --> WriteDB[寫入資料庫]
        WriteDB -- 資料同步 (如事件) --> ReadDB[讀取資料庫]
        App2 -- 讀取 --> QueryModel[查詢模型]
        QueryModel --> ReadDB
    end
```

### 核心概念

- **Command (命令)：** 任何會改變系統狀態的操作，如 `createUser`, `updateProductPrice`。它通常不返回值。
- **Query (查詢)：** 任何只讀取系統狀態的操作，如 `getUserById`, `findProducts`。它絕不能改變系統狀態。

### CQRS 帶來的權衡

**優點：**

- **獨立擴展：** 如果你的系統是讀取密集型（99% 的操作是讀取），你可以獨立地擴展你的讀取資料庫（例如增加更多的從節點），而無需影響寫入效能。
- **模型優化：** 寫入模型可以專注於資料一致性和業務規則；讀取模型可以被高度優化（例如反正規化）以應對複雜的查詢需求。
- **技術棧靈活性：** 寫入端可以用關聯式資料庫保證異動，讀取端可以用 Elasticsearch 來做全文搜尋。

**挑戰 (您答錯的點)：**

- **最終一致性 (Eventual Consistency)：** 這是最大的挑戰。當一個寫入操作完成後，資料需要一些時間才能同步到讀取資料庫。在這短暫的延遲期間，使用者可能會讀到舊的資料。如何處理這種延遲是 CQRS 實踐的核心難點。
- **系統複雜度增加：** 你需要維護兩個模型、兩個資料庫以及它們之間的同步機制，這無疑增加了開發和維護的複雜度。
- **硬體成本可能增加：** 因為需要獨立的讀寫資料庫。

**結論：** CQRS 是一種強大的高階架構模式，它用增加的複雜度和接受最終一致性為代價，換取了極高的系統效能和擴展性。
